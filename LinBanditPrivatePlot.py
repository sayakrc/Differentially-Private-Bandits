# plot function accompanying the paper "Shuffle Private Linear Contextual Bandits" (ICML 2022)
# code is built on https://github.com/vaswanis/randucb


import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np

import os

mpl.rcParams["axes.linewidth"] = 0.75
mpl.rcParams["grid.linewidth"] = 0.75
mpl.rcParams["lines.linewidth"] = 0.75
mpl.rcParams["patch.linewidth"] = 0.75
mpl.rcParams["xtick.major.size"] = 3
mpl.rcParams["ytick.major.size"] = 3

mpl.rcParams["pdf.fonttype"] = 42
mpl.rcParams["ps.fonttype"] = 42
mpl.rcParams["font.size"] = 14
mpl.rcParams["axes.titlesize"] = "large"
mpl.rcParams["legend.fontsize"] = "large"

mpl.rcParams["text.usetex"] = True
mpl.rcParams['text.latex.preamble'] = [
    r'\usepackage{amsmath}',
    r'\usepackage{amssymb}']

print("matplotlib %s" % mpl.__version__)

def linestyle2dashes(style):
    if style == 'solid':
        return (10, ())
    elif style == 'dotted':
        return (0, (1, 1))
    elif style == 'loosely dotted':
        return (0, (1, 10))
    elif style == 'densely dotted':
        return (0, (1, 1))
    elif style == 'dashed':
        return (0, (5, 5))
    elif style == 'loosely dashed':
        return (0, (5, 10))
    elif style == 'densely dashed':
        return (0, (5, 1))
    elif style == 'dashdotted':
        return (0, (3, 5, 1, 5))
    elif style == 'loosely dashdotted':
        return (0, (3, 10, 1, 10))
    elif style == 'densely dashdotted':
        return (0, (3, 1, 1, 1))
    elif style == 'dashdotdotted':
        return (0, (3, 5, 1, 5, 1, 5))
    elif style == 'loosely dashdotdotted':
        return (0, (3, 10, 1, 10, 1, 10))
    elif style == 'densely dashdotdotted':
        return (0, (3, 1, 1, 1, 1, 1))

n = 20000

step = np.arange(1, n + 1)
sube = (step.size // 10) * np.arange(1, 11) - 1

environments = [    
    ("Bernoulli (d=5,eps=0.2,delta=0.1,B=20)", 5, 0.2, 0.1, 20)    
]

algorithms = [
    ("LinUCB", "black", "solid", "LinUCB"), 
    ("JDPLinUCB", "blue", "solid", "LinUCB-JDP"),
    ("SDPLinUCBPAmp", "red", "solid", "LinUCB-SDP-Amp"),
    ("SDPLinUCBPVec", "green", "solid", "LinUCB-SDP-Vec"),
    ("LDPLinUCB", "cyan", "solid", "LinUCB-LDP")    
]

plt.figure(figsize=(5, 3))

for fig_idx, env_def in enumerate(environments):
    env_name, d, epsilon, delta, BatchSize = env_def[0], env_def[1], env_def[2], env_def[3], env_def[4]
    
    res_dir = os.path.join("PathToFile", "Results", "Lin", env_name) # specify path to saved file generated by LinBanditPrivate.py
    
    plt.subplot(1, 1, fig_idx + 1)
    for alg_idx, alg_def in enumerate(algorithms):
        alg_name, alg_color, alg_line, alg_label = alg_def[0], alg_def[1], alg_def[2], alg_def[3]
        
        fname = os.path.join(res_dir, alg_name)
        cum_regret = np.loadtxt(fname, delimiter=",")
        std_regret = cum_regret.std(axis=1) / np.sqrt(cum_regret.shape[1])

        plt.plot(step, cum_regret.mean(axis=1), alg_color, linestyle=linestyle2dashes(alg_line), label=alg_label)

        plt.fill_between(step,
                         cum_regret.mean(axis=1) - std_regret,
                         cum_regret.mean(axis=1) + std_regret,
                         color=alg_color, alpha=0.2, linewidth=0)
    
    plt.xlabel(r"Round")
    plt.ylabel("Regret") 
    plt.legend(loc= 'best', fontsize=12)
    plt.grid(True)       
        
plot_dir = os.path.join(".", "Plots", "Lin", env_name)
os.makedirs(plot_dir, exist_ok=True)

fig_name = "benchmarking.pdf"
fname = os.path.join(plot_dir, fig_name)
plt.savefig(fname, format = "pdf", dpi = 1200, bbox_inches="tight")
plt.show()